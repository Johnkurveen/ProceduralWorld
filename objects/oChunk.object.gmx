<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>loadChunk();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>unloadChunk();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//check for despawn
if(pointInDespawnRange(x+chunkSize/2,y+chunkSize/2)){
    instance_destroy();
}

//mouse interaction
//if(mouse_check_button(mb_left)){
if(0){
    var relX = mouse_x - x;
    var relY = mouse_y - y;
    var rad = 20;
    var xInRange = -rad &lt; relX &amp;&amp; relX &lt; chunkSize + rad;
    var yInRange = -rad &lt; relY &amp;&amp; relY &lt; chunkSize + rad;
    if(xInRange &amp;&amp; yInRange){
        for(var i = 0; i &lt; chunkSize/blockSize; i++){
            for(var j = 0; j &lt; chunkSize/blockSize; j++){
                if(point_distance(i*blockSize,j*blockSize,relX,relY) &lt;= rad){
                    grid[# i,j] = max(0,grid[# i,j] -1);
                }
            }
        }    
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var r=0, g=0, b=0;
var cal=255/100;
var check=1;
var i, j;
var size=chunkSize / blockSize;

var zz;
var waterLevelTemp=waterLevel;
var r=0,b=0,g=0;
var mountian=75;
var shore=1; // shore offset





for(i = 0; i &lt; size; i++){
    for(j = 0; j &lt; size; j++){
        
        if(showR){
            check=0;
    
    
    
            if(keyboard_check(ord("1"))&amp;&amp;RESOURCES&gt;0){
                col=ds_grid_get(resourceGrids[| 0], i, j)*cal;
                draw_set_color( make_color_rgb(0,0,col));
            }
            /*else if(chunkData[| 0]==1){
                draw_set_color( make_color_rgb(50,50,50));
            }*/
               
            else if(keyboard_check(ord("2"))&amp;&amp;RESOURCES&gt;1){
            
                col=ds_grid_get(resourceGrids[| 1], i, j)*cal;
                draw_set_color( make_color_rgb(0,col,0));
            }
            
            else if(keyboard_check(ord("3"))&amp;&amp;RESOURCES&gt;2){
                col=ds_grid_get(resourceGrids[| 2], i, j)*cal;
                draw_set_color( make_color_rgb(col,0,0));
            }
            
            else if(keyboard_check(ord("4"))&amp;&amp;RESOURCES&gt;3){
                col=ds_grid_get(resourceGrids[| 3], i, j)*cal;
                draw_set_color( make_color_rgb(0,0,col));
            }
                
            else if(keyboard_check(ord("5"))&amp;&amp;RESOURCES&gt;3){
                b=ds_grid_get(resourceGrids[| 3], i, j)*cal;
                b+=ds_grid_get(resourceGrids[| 0], i, j)*cal;
                g=ds_grid_get(resourceGrids[| 1], i, j)*cal;
                r=ds_grid_get(resourceGrids[| 2], i, j)*cal;
                draw_set_color( make_color_rgb(r,g,b));
            }
            
            else if(keyboard_check(ord("6"))&amp;&amp;RESOURCES&gt;3){
            var temp=0;
                for (var r=0, col=0; r&lt;RESOURCES; r++){
                    temp=ds_grid_get(resourceGrids[| r], i, j); // Resource in grid
                    if(temp){ // If not 0
                        temp=(temp+ds_grid_get(res_constant,6,r)/4); // Adds offsets
                        if(temp&gt;0){ // Makes positive adds to col
                            col+=temp;
                            
                        }
                    }
                               
                }
                col*=cal/RESOURCES; // 255 Max
                if(col&gt;100){
                    draw_set_color( make_color_rgb(col,0,col));
                }
                else {
                    draw_set_color( make_color_rgb(col,col,col));
                }
            }
            else if(keyboard_check(ord("7"))&amp;&amp;RESOURCES&gt;3){ // Manages ranks
                var rank; var resourceMax;
                rank=ds_grid_get(resourceGrids[| 4], i, j)*cal; // scales max of 100 to 255
                resourceMax=ds_grid_get(resourceGrids[| 5], i, j)
                switch(resourceMax){
                case(0):
                case(3):
                    b=rank;
                    r=0; g=0;
                break;
                case(1):
                    g=rank;
                    r=0; b=0;
                break;
                case(2):
                    r=rank;
                    b=0; g=0;
                break;
                default:
                    r=20;
                    b=20;
                    g=20;
                }
                draw_set_color( make_color_rgb(r,g,b));
            }
            else{
                check=1;
            }
            }
            // Draw alt map
            if(check){
                zz=ds_grid_get(terrainGrids[| 0], i, j); // This just needs 0-100 altitude
                if((zz &gt; waterLevelTemp+shore)&amp;&amp;(zz&lt;=mountian)){
                    //g = 50 + ((zz - waterLevelTemp) / (100-waterLevelTemp)) * 200;
                    g = 50 + (zz - waterLevelTemp) * 3.7;
                    r=0; b=0;
                }
                else if(zz &lt; waterLevelTemp){
                    b = 50 + (zz / waterLevelTemp) * 200;
                    r=0; g=0;
                }
                else if(zz &lt;= waterLevelTemp+shore){ // Makes shore blocks sandy
                    r=194;
                    g=178;
                    b=128;
                }
                else if(zz == 102){ // Mark towns
                    g = 25;
                    b = 20;
                    r = 250;
                }
                else if(zz == 101){ // Mark towns
                    g = 25;
                    b = 20;
                    r = 50;
                }
                else if(zz &gt; mountian){ // For mountain tops
                    g = 155+(zz-75)*100/(100-75);
                    b = 155+(zz-75)*100/(100-75);
                    r = 155+(zz-75)*100/(100-75);
                }
                else{
                    r=50; g=50; b=50;
                }
            
            
            
                //col=ds_grid_get(terrainGrids[| 0], i, j); // This just needs 0-100 altitude
                //draw_set_color( getColorZ(col, waterLevelTemp));
                draw_set_color(make_color_rgb(r,g,b));
            }

        draw_rectangle(x + i*blockSize, y + j*blockSize, 
            x + (i+1)*blockSize-1,y + (j+1)*blockSize-1,false);
        
    }
}


// Draws chunk boundry
draw_set_color(c_red);
draw_rectangle(x,y,x+chunkSize,y+chunkSize,true);

draw_set_color(c_black);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
